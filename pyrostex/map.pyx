# THIS FILE GENERATED BY CYMACRO.
# CHANGES MADE HERE WILL NOT BE PRESERVED.

# cython: infer_types=True, boundscheck=False, nonecheck=False, language_level=3, initializedcheck=False

"""
Maps for storing data about a map for a sphere.
"""

# Note on method naming convention:
#   methods ending in underscore (ex: TextureMap.v_from_lat_lon_)
#   are methods that are meant to be called from c, and accept
#   c - specific arguments, such as memory views.

# todo:
#   refactor to use memory view of floats instead of np array
#   generate wind point_vector map from pressure map
#   remove redundant FastNoise wrapper class
#   replace r, u, ur methods for gradient finding

# package imports
import numpy as np
import png
import itertools as itr
import struct  # used for storing bytes in files

cimport numpy as np
cimport cython

from mathutils import Vector

from math import radians
from libc.math cimport cos, sin, atan2, sqrt, pow, fabs, ceil, log2, isnan
from libc.stdlib cimport malloc, free

from cymacro import macro  # dummy function for defining macros

# project imports
from .includes cimport cmathutils as mu

# includes
include "flags.pxi"
include "macro.pxi"

DEF PI = 3.1415926535897932384626433832795028841971
DEF TAU = 6.2831853071795864769252867665590057683942
DEF QTR_PI = 0.785398163397448309615660845819875721049275

DEF MIN_LAT = -1.57079632679489661923132169163975144209855
DEF MAX_LAT = 1.57079632679489661923132169163975144209855
DEF LAT_RANGE = PI
DEF MIN_LON = -PI
DEF MAX_LON = PI
DEF LON_RANGE = TAU

DEF GAUSS_SAMPLES = 4


#######################################################################
# DEFINITION MACROS
#######################################################################

# these macros provide a workaround for the lack of multiple
# inheritance in cython

# Grey-scale Definitions

GREY_DATA_DEFINITIONS = ''  # Macro placeholder

VECTOR_DATA_DEFINITIONS = ''  # Macro placeholder


REGION_DATA_DEFINITIONS = ''  # Macro placeholder


#######################################################################
# ABSTRACT MAPS
#######################################################################


cdef class AbstractMap:
    """
    Abstract map type storing fields and methods not specific to
    any one data type or arrangement (Cube, LatLon, Tile, etc)
    """
    def __init__(self, width=2048 * 3, height=2048 * 2, viewed_map=None, **kwargs):
        """
        Creates a LatLonMap either from a passed file path or
        passed parameters.
        :param kwargs: path, width, height
        """
        if not isinstance(width, int):
            raise TypeError(f'Expected w to be an int, got: {width}')
        if not isinstance(height, int):
            raise TypeError(f'Expected w to be an int, got: {height}')
        self.width = width
        self.height = height
        self._ref_pos = mu.vec2Zero()

        if viewed_map:
            self.has_original_array = 0
            self._view_arr(viewed_map)
        else:
            self.has_original_array = 1
            self._allocate_arr()

        if sum([k in kwargs.keys() for k in ('path', 'arr', 'prototype')]) > 1:
            raise ValueError(
                "Only one of {'path', 'arr', 'prototype'} should be passed")
        if 'path' in kwargs:
            path = kwargs['path']
            self.load_arr(path)
        # get data from prototype if one was passed
        elif 'prototype' in kwargs:
            p = kwargs.get('prototype')
            self.clone(p)

        if not self.width > 0:
            raise ValueError('Invalid width: {}'.format(self.width))
        if not self.height > 0:
            raise ValueError('Invalid height: {}'.format(self.height))

    cdef void _allocate_arr(self) except *:
        raise NotImplementedError(
            'Abstract map without data type cannot be instantiated')

    cdef void _view_arr(self, AbstractMap m) except *:
        self._arr = m.get_arr()

    def __dealloc__(self):
        if self.has_original_array:
            free(self._arr)

    cpdef void load_arr(self, unicode path) except *:
        """
        Loads and returns texture data from passed path.
        :param str path
        """
        raise NotImplementedError

    cpdef void save(self, unicode path) except *:
        """
        Saves TextureMap data to passed path.
        :param str path
        """
        raise NotImplementedError

    cdef void set_arr(self, void *arr):
        """
        Sets array to that passed
        """
        free(self._arr)
        self.has_original_array = False
        self._arr = arr

    cdef void clone(self, AbstractMap p) except *:
        """
        Clones array information from passed prototype, converting
        information to a new format (Cube from LatLon for example)
        if needed.
        :param p TextureMap to clone data from
        :param width int width of new data array
        :param height int height of new data array
        """
        raise NotImplementedError

    cdef void *get_arr(self):
        return self._arr

    # Position conversions

    cpdef tuple xy_from_lat_lon(self, pos):
        raise NotImplementedError()

    cdef vec2 xy_from_lat_lon_(self, latlon pos) except *:
        raise NotImplementedError()

    cpdef tuple xy_from_rel_xy(self, pos):
        raise NotImplementedError()

    cdef vec2 xy_from_rel_xy_(self, vec2 pos) except *:
        raise NotImplementedError()

    cpdef tuple xy_from_vector(self, vector):
        raise NotImplementedError()

    cdef vec2 xy_from_vector_(self, vec3 vector) except *:
        raise NotImplementedError()

    # Other Conversions

    cpdef object vector_from_xy(self, pos):
        raise NotImplementedError()

    cdef vec3 vector_from_xy_(self, vec2 pos) nogil except *:
        with gil:
            raise NotImplementedError()

    cpdef tuple lat_lon_from_xy(self, tuple pos):
        raise NotImplementedError()

    cdef latlon lat_lon_from_xy_(self, vec2 xy_pos) nogil except *:
        with gil:
            raise NotImplementedError()

    # Out

    cpdef void write_png(self, unicode out) except *:
        raise NotImplementedError()

    @property
    def size(self):
        return self.width * self.height


#######################################################################
# CUBE MAP
#######################################################################


cdef class CubeMap(AbstractMap):
    """
    A cube map is a more efficient way to store data about a sphere,
    that also involves less stretching than a LatLonMap
    """
    def __init__(self, width, height, **kwargs):
        if not isinstance(width, int):
            raise TypeError(f'Expected w to be int, got: {width}')
        if not isinstance(height, int):
            raise TypeError(f'Expected h to be int, got: {height}')
        assert width > 0, width
        assert height > 0, height

        if not width / 3 % 1 == 0:
            raise ValueError(f'Expected width divisible by 3. Got: {width}')
        if not height / 2 % 1 == 0:
            raise ValueError(f'Expected height divisible by 2. Got: {height}')

        self.tile_width = width / 3
        self.two_thirds_width = width * 2 / 3
        self.tile_height = height / 2

        super().__init__(width, height, **kwargs)

        # create tiles

        self.tile_maps = []
        for i in range(6):
            tile = CubeSide(i, self)  # cast pointer to int for py
            tile.cube = self
            # uppermost tile has no parent.
            self.tile_maps.append(tile)

    cpdef tuple xy_from_lat_lon(self, pos):
        """
        Gets xy mapping of passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: pos
        """
        tile = self.tile_from_lat_lon(pos)
        IF ASSERTS:
            assert isinstance(tile, TileMap)
        return tile.xy_from_lat_lon_(pos)

    cpdef tuple xy_from_vector(self, vector):
        """
        Gets pixel value at passed position on this map.
        :param vector: Vector (x, y, z)
        :return: x, y
        """
        return self.xy_from_vector_(cp2v_3d(vector))

    cdef vec2 xy_from_vector_(self, vec3 vector) except *:
        cdef latlon lat_lon = lat_lon_from_vector_(vector)
        cdef TileMap tile = self.tile_from_lat_lon_(lat_lon)
        return tile.xy_from_vector_(vector)

    cpdef CubeSide get_tile(self, int index):
        """
        gets the tile of the passed index
        :param index: int
        :return: TileMap
        """
        return self.tile_maps[index]

    cpdef CubeSide tile_from_vector(self, vector):
        """
        Gets the tile on which the value identified by the passed vector
        is located.
        :param pos tuple(latitude, longitude)
        :return integer in range 0, 6
        """
        return self.tile_from_vector_(cp2v_3d(vector))

    cdef CubeSide tile_from_vector_(self, vec3 vector):
        return self.get_tile(self.tile_index_from_vector_(vector))

    cdef int tile_index_from_vector_(self, vec3 vector):
        # prevent repeated calls to fabs and vector
        cdef double x, y, z, abs_x, abs_y, abs_z
        x = vector.x
        y = vector.y
        z = vector.z
        abs_x = fabs(x)  # get absolute from float
        abs_y = fabs(y)
        abs_z = fabs(z)

        # see if vector can be quickly placed in one tile
        if abs_x >= abs_y and abs_x >= abs_z:
            if x > 0:
                return 0
            else:
                return 2
        elif abs_y >= abs_x and abs_y >= abs_z:
            if y > 0:
                return 3
            else:
                return 1
        elif abs_z >= abs_x and abs_z >= abs_y:
            if z > 0:
                return 4
            else:
                return 5

    cpdef CubeSide tile_from_lat_lon(self, lat_lon):
        """
        Gets the tile on which the passed lat, lon value is located.
        :param pos tuple(latitude, longitude)
        :return integer in range 0, 6
        """
        cdef latlon lat_lon_ = cp2ll(lat_lon)
        if not MIN_LAT <= lat_lon_.lat <= MAX_LAT:
            raise ValueError('latitude outside range: {}'.format(lat_lon_.lat))
        if not MIN_LON <= lat_lon_.lon <= MAX_LON:
            raise ValueError('longitude outside range: {}'
                             .format(lat_lon_.lon))
        return self.tile_from_lat_lon_(lat_lon_)

    cdef CubeSide tile_from_lat_lon_(self, latlon lat_lon):
        IF ASSERTS:
            assert MIN_LAT <= lat_lon.lat <= MAX_LAT, lat_lon
            assert MIN_LON <= lat_lon.lon <= MAX_LON, lat_lon
        cdef vec3 vector = vector_from_lat_lon_(lat_lon)
        return self.tile_from_vector_(vector)

    cpdef CubeSide tile_from_xy(self, pos):
        return self.tile_from_xy_(cp2v_2d(pos))

    cdef CubeSide tile_from_xy_(self, vec2 pos):
        return self.tile_maps[self.tile_index_from_xy_(pos)]

    cpdef short tile_index_from_xy(self, pos):
        return self.tile_index_from_xy_(cp2v_2d(pos))

    @cython.cdivision(True)
    cdef short tile_index_from_xy_(self, vec2 pos) nogil:
        """
        Private method for finding the index corresponding to
        a passed position.
        """
        if not 0 <= pos.x < self.width:
            with gil:
                raise ValueError(
                    'x {} outside range: 0-{}'.format(pos.x, self.width))
        if not 0 <= pos.y < self.height:
            with gil:
                raise ValueError(
                    'y {} outside range: 0-{}'.format(pos.y, self.height))
        if pos.x < self.tile_width:
            i = 0
        elif pos.x < self.two_thirds_width:
            i = 1
        else:
            i = 2
        if pos.y >= self.height / 2:
            i += 3
        return i

    @cython.wraparound(False)
    cpdef vector_from_xy(self, pos):
        cdef vec3 vector_ = self.vector_from_xy_(cp2v_2d(pos))
        return Vector((vector_.x, vector_.y, vector_.z))

    @cython.wraparound(False)
    cdef vec3 vector_from_xy_(self, vec2 pos) nogil except *:
        cdef vec2 tile_ref_pos
        cdef vec2 rel_pos

        IF ASSERTS:
            with gil:
                assert 0 <= pos.x <= self.width - 1, pos.x
                assert 0 <= pos.y <= self.height - 1, pos.y

        tile_index = self.tile_index_from_xy_(pos)
        tile_ref_pos = self.reference_position_(tile_index)
        rel_pos.x = pos.x - tile_ref_pos.x
        rel_pos.y = pos.y - tile_ref_pos.y
        return self.vector_from_tile_xy_(tile_index, rel_pos)

    @cython.cdivision(True)
    @cython.wraparound(False)
    cdef vec3 vector_from_tile_xy_(self, int tile_index, vec2 pos) nogil except *:
        """
        Gets vector from xy position of passed face tile
        """
        cdef vec3 vector
        a_index, b_index = pos.x, pos.y
        if not 0 <= a_index < self.tile_width:
            with gil:
                raise ValueError('Passed x {} was outside range 0-{}'
                                 .format(a_index, self.tile_width))
        if not 0 <= b_index < self.tile_height:
            with gil:
                raise ValueError('Passed y {} was outside range 0-{}'
                                 .format(b_index, self.tile_height))
        min_rel_x = -1
        min_rel_y = -1
        max_rel_x = 1
        max_rel_y = 1
        # flip values if needed
        if min_rel_x > max_rel_x:
            min_rel_x, max_rel_x = max_rel_x, min_rel_x
        if min_rel_y > max_rel_y:
            min_rel_y, max_rel_y = max_rel_y, min_rel_y
        a_range = max_rel_x - min_rel_x
        b_range = max_rel_y - min_rel_y
        # get relative positions from map indices
        map_rel_x = a_index / self.tile_width
        map_rel_y = b_index / self.tile_height
        a = map_rel_x * a_range + min_rel_x
        b = map_rel_y * b_range + min_rel_y
        # assert -1 <= a <= 1, a
        # assert -1 <= b <= 1, b
        if tile_index == 0:
            vector.x, vector.y, vector.z = 1, a, b
        elif tile_index == 1:
            vector.x, vector.y, vector.z = a, -1, b
        elif tile_index == 2:
            vector.x, vector.y, vector.z = -1, -a, b
        elif tile_index == 3:
            vector.x, vector.y, vector.z = -a, 1, b
        elif tile_index == 4:
            vector.x, vector.y, vector.z = a, b, 1
        elif tile_index == 5:
            vector.x, vector.y, vector.z = -a, b, -1
        else:
            with gil:
                raise ValueError('Invalid face index: {}'.format(tile_index))
        return vector

    cdef latlon lat_lon_from_xy_(self, vec2 xy_pos) nogil except *:
        return lat_lon_from_vector_(self.vector_from_xy_(xy_pos))

    cpdef get_reference_position(self, tile_index):
        if not 0 <= tile_index < 6:  # if outside valid range
            raise IndexError(tile_index)
        elif tile_index < 3:
            return tile_index * self.tile_width, 0
        elif tile_index < 6:
            return (tile_index - 3) * self.tile_width, self.tile_height

    cdef vec2 reference_position_(self, int tile_index) nogil except *:
        cdef vec2 ref_pos
        IF ASSERTS:
            with gil:
                assert 0 <= tile_index < 6
        if tile_index < 3:
            ref_pos.x =  tile_index * self.tile_width
            ref_pos.y = 0
        else:
            ref_pos.x = (tile_index - 3) * self.tile_width
            ref_pos.y = self.tile_height

        IF ASSERTS:
            with gil:
                assert 0 <= ref_pos.x <= self.width * 2 / 3, ref_pos
                assert 0 <= ref_pos.y <= self.height / 2, ref_pos
        return ref_pos

cdef class LatLonMap(AbstractMap):
    """
    Stores a latitude-longitude texture map
    """

    def __init__(self, **kwargs):
        """
        Creates a LatLonMap either from a passed file path or
        passed parameters.
        :param kwargs: path, width, height
        """
        super().__init__(**kwargs)

    cpdef tuple xy_from_vector(self, vector):
        """
        Gets pixel value at passed position on this map.
        :param vector: Vector (x, y, z)
        :return: PixelValue
        """
        return self.xy_from_vector_(cp2v_3d(vector))

    cdef vec2 xy_from_vector_(self, vec3 vector) except *:
        return self.xy_from_lat_lon_(lat_lon_from_vector_(vector))

    @cython.wraparound(False)
    cpdef tuple xy_from_lat_lon(self, lat_lon):
        assert MIN_LON <= lat_lon[1] <= MAX_LON
        assert MIN_LAT <= lat_lon[0] <= MAX_LAT
        cdef vec2 xy_pos = self.xy_from_lat_lon_(cp2ll(lat_lon))
        return xy_pos.x, xy_pos.y

    @cython.cdivision(True)
    @cython.wraparound(False)
    cdef vec2 xy_from_lat_lon_(self, latlon lat_lon) except *:
        cdef vec2 xy_pos
        cdef double x, y
        lat = lat_lon.lat
        lon = lat_lon.lon
        x_ratio = lon / LON_RANGE + 0.5  # x as ratio of 0 to 1
        y_ratio = lat / LAT_RANGE + 0.5  # y as ratio from 0 to 1
        x = x_ratio * (self.width - 1)  # max index is 1 less than size
        y = y_ratio * (self.height - 1)  # max index is 1 less than size
        # correct floating point errors that take values outside range
        if x > self.width - 1:
            # if floating point error has taken x over width, correct it.
            # assert x - self.width - 1 < 0.01, x  # if larger, something's wrong
            x = self.width - 1
        elif x < 0:
            # assert x > -0.01, x
            x = 0
        if y > self.height - 1:
            # assert y - self.height - 1 < 0.01, y
            y = self.height - 1
        elif y < 0:
            # assert y > -0.01, y
            y = 0
        # store result
        xy_pos.x = x
        xy_pos.y = y
        return xy_pos

    @cython.cdivision(True)
    cpdef tuple lat_lon_from_xy(self, tuple pos):
        x, y = pos
        relative_x = x / self.width
        relative_y = y / self.height
        lon = (relative_x - 0.5) * MAX_LON
        lat = (relative_y - 0.5) * MAX_LAT
        return lat, lon


#######################################################################
# TILE MAP
#######################################################################


cdef class TileMap(AbstractMap):
    """
    Stores a square texture map that is mapped to a portion of a sphere.
    """

    def __init__(self, width, height, p1, p2, cube_face, viewed_map=None, **kwargs):
        """
        Creates TileMap from upper left and lower right corner position
        relative to the face of the cube-map.
        Ex: (0,0) is center, (1,1) is upper right, (-1,1) is lower right
        Cube face is the face of the cube on which this tile is located.
        :param p1: tuple(x, y)
        :param p2: tuple(x, y)
        """
        if not isinstance(width, int):
            raise TypeError(f'Expected w to be int, got: {width}')
        if not isinstance(height, int):
            raise TypeError(f'Expected h to be int, got: {height}')
        assert width > 0, width
        assert height > 0, height
        if not isinstance(cube_face, int):
            raise TypeError(f'Expected cube side index, got {cube_face}')
        super().__init__(width, height, viewed_map, **kwargs)
        self.cube_face = cube_face
        self.p1 = cp2v_2d(p1)
        self.p2 = cp2v_2d(p2)
        self.parent = None

    cpdef tuple xy_from_lat_lon(self, pos):
        """
        Gets pixel value at passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: PixelValue
        """
        vector = vector_from_lat_lon(pos)
        xy = self.xy_from_vector(vector)
        return xy

    cpdef tuple xy_from_vector(self, vector):
        """
        Gets pixel value at passed position on this map.
        :param vector: Vector (x, y, z)
        :return: PixelValue
        """
        return self.xy_from_vector_(cp2v_3d(vector))

    @cython.cdivision(True)
    @cython.wraparound(False)
    cdef vec2 xy_from_vector_(self, vec3 vector) except *:
        """
        Gets value associated with passed vector.
        Unlike above version, vector is a memory view, not an object.
        """
        cdef double x, y, z
        cdef vec2 pos
        x = vector.x
        y = vector.y
        z = vector.z
        if x == 0. and y == 0. and z == 0.:
            raise ValueError('Passed vector was (0, 0, 0)')
        if self.cube_face == 0:
            a = y / x
            b = z / x
        elif self.cube_face == 1:
            a = x / -y
            b = z / -y
        elif self.cube_face == 2:
            a = y / x
            b = z / -x
        elif self.cube_face == 3:
            a = x / -y
            b = z / y
        elif self.cube_face == 4:
            a = x / z
            b = y / z
        elif self.cube_face == 5:
            a = x / z
            b = y / -z
        else:
            raise IndexError(self.cube_face)
        # correct minor floating point errors (~1e-12 or smaller)
        if a < -1:
            IF ASSERTS:
                assert a + 1 > -1e-12, a
            a = -1
        if a > 1:
            IF ASSERTS:
                assert a - 1 < 1e-12, a
            a = 1
        if b < -1:
            IF ASSERTS:
                assert b + 1 > -1e-12, b
            b = -1
        if b > 1:
            IF ASSERTS:
                assert b - 1 < 1e-12, b
            b = 1
        IF ASSERTS:
            assert -1 <= a <= 1 and -1 <= b <= 1, \
                'position outside expected range: ({},{}), tile: {}' \
                .format(a, b, self.cube_face)
        # convert a and b from (-1,-1) range to (0,1)
        pos.x = a / 2 + 0.5
        pos.y = b / 2 + 0.5
        IF ASSERTS:
            assert 0 <= pos.x <= 1, \
                'a value: {}, tile: {}'.format(pos.x, self.cube_face)
            assert 0 <= pos.y <= 1, \
                'b value: {}, tile: {}'.format(pos.y, self.cube_face)
        return self.xy_from_rel_xy_(pos)

    cdef vec2 xy_from_rel_xy_(self, vec2 pos) except *:
        return mu.vec2Add(pos, self._ref_pos)

    # getters of map indices from passed vector
    # these methods are intended to retrieve positions that will be
    # sampled in order to determine the value of the map at a position
    # that does not perfectly align with any one set of indices.

    cpdef get_sub_tile(self, p1, p2):
        """
        Gets sub-tile of this tile map
        :param p1: lower left corner
        :param p2: upper right corner
        :return: TileMap
        """
        # todo

    cpdef vector_from_xy(self, pos):
        cdef vec2 pos_ = cp2v_2d(pos)
        cdef vec3 vector = self.vector_from_xy_(pos_)
        return Vector((vector.x, vector.y, vector.z))

    @cython.cdivision(True)
    @cython.wraparound(False)
    cdef vec3 vector_from_xy_(self, vec2 pos) nogil except *:
        cdef vec3 vector
        cdef double a, b, a_range, b_range
        cdef double min_rel_x, max_rel_x, min_rel_y, max_rel_y
        a_index, b_index = pos.x, pos.y
        if not 0 <= a_index <= self.width - 1:
            with gil:
                raise ValueError('Passed x {} was outside range 0-{}'
                                 .format(a_index, self.width))
        if not 0 <= b_index <= self.height - 1:
            with gil:
                raise ValueError('Passed x {} was outside range 0-{}'
                                 .format(b_index, self.height))
        min_rel_x = self.p1.x
        min_rel_y = self.p1.y
        max_rel_x = self.p2.x
        max_rel_y = self.p2.y
        # flip values if needed
        if min_rel_x > max_rel_x:
            min_rel_x, max_rel_x = max_rel_x, min_rel_x
        if min_rel_y > max_rel_y:
            min_rel_y, max_rel_y = max_rel_y, min_rel_y
        a_range = max_rel_x - min_rel_x
        b_range = max_rel_y - min_rel_y
        # get relative positions from map indices
        map_rel_x = a_index / self.width
        map_rel_y = b_index / self.height
        a = map_rel_x * a_range + min_rel_x
        b = map_rel_y * b_range + min_rel_y
        # assert -1 <= a <= 1, a
        # assert -1 <= b <= 1, b
        if self.cube_face == 0:
            vector.x, vector.y, vector.z = 1, a, b
        elif self.cube_face == 1:
            vector.x, vector.y, vector.z = a, -1, b
        elif self.cube_face == 2:
            vector.x, vector.y, vector.z = -1, -a, b
        elif self.cube_face == 3:
            vector.x, vector.y, vector.z = -a, 1, b
        elif self.cube_face == 4:
            vector.x, vector.y, vector.z = a, b, 1
        elif self.cube_face == 5:
            vector.x, vector.y, vector.z = -a, b, -1
        else:
            with gil:
                raise ValueError(
                    'Invalid face index: {}'.format(self.cube_face))
        return vector


#######################################################################
# CUBE SIDE
#######################################################################


cdef class CubeSide(TileMap):

    def __init__(self, cube_face, cube_map):
        if not isinstance(cube_face, int):
            raise TypeError(f'Expected cube side index, got {cube_face}')
        self.cube_face = cube_face
        self.p1 = mu.vec2New(-1, -1)
        self.p2 = mu.vec2New(1, 1)
        self.parent = None
        w = cube_map.tile_width
        h = cube_map.tile_height

        if not w % 1 == 0:
            raise ValueError(f'Expected to be passed int for width. got: {w}')
        if not h % 1 == 0:
            raise ValueError(f'Expected to be passed int for height. got: {h}')

        self.cube = cube_map
        super().__init__(w, h, (-1, -1), (1, 1), cube_face, cube_map)

        self._ref_pos = self._find_reference_position()

    cdef vec2 _find_reference_position(self):
        IF ASSERTS:
            assert 0 <= self.cube_face < 6, self.cube_face
        if self.cube_face < 3:
            return mu.vec2New(self.cube_face * self.width, 0.)
        elif self.cube_face < 6:
            return mu.vec2New((self.cube_face - 3) * self.width, self.height)

    @property
    def reference_position(self):
        return self._ref_pos.x, self._ref_pos.y


#######################################################################
# TEXTURE MAPS  (Floating Point Maps)
#######################################################################


cdef class GreyCubeMap(CubeMap):
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(a_t))
    
    cpdef void load_arr(self, unicode path) except *:
        cdef np.ndarray arr
    
        arr = np.load(path, allow_pickle=False)
    
        # validate data
        if not arr.dtype == np.float32:
            raise TypeError(
                f'Loaded arr had wrong data type. Got: {arr.dtype} '
                f'Expected: float32'
            )
    
        if not len(arr) == self.height:
            raise ValueError(
                f'Passed array of unexpected height. Got: {len(arr)}, '
                f'expected {self.height}'
            )
    
        if not len(arr[0]) == self.width:
            raise ValueError(
                f'Passed array of unexpected width. Got: {len(arr[1])}, '
                f'expected {self.width}'
            )
    
        # transfer values
        for y in range(self.height):
            for x in range(self.width):
                (<a_t *>self._arr)[y * self.width + x] = arr[y, x]
    
    cpdef void save(self, unicode path) except *:
        n_arr = np.ndarray((self.height, self.width), dtype=np.float32)
    
        # populate numpy arr
        for y in range(self.height):
            for x in range(self.width):
                n_arr[y, x] = (<a_t *>self._arr)[y * self.width + x]
    
        np.save(path, n_arr, allow_pickle=False)
        
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, GreyCubeMap):
            self.clone_(<GreyCubeMap> p)
        elif isinstance(p, GreyLatLonMap):
            self.clone_(<GreyLatLonMap> p)
        elif isinstance(p, GreyTileMap):
            self.clone_(<GreyTileMap> p)
        elif isinstance(p, GreyCubeSide):
            self.clone_(<GreyCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, grey_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef a_t v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    cpdef a_t v_from_lat_lon(self, pos) except? -1.:
        """
        Gets pixel value at passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: a_t
        """
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef a_t v_from_lat_lon_(self, latlon pos) except? -1.:
        """
        Gets value stored for passed latitude, longitude
        :param pos lat, lon
        :return int
        """
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef a_t v_from_xy(self, pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        :param pos: pos
        :return int
        """
        cdef vec2 pos_ = cp2v_2d(pos)
        if not 0 <= pos_.x < self.width:
            raise ValueError('x value: {} was greater than width: {}'
                             .format(pos_.x, self.width))
        if not 0 <= pos_.y < self.height:
            raise ValueError('y value: {} was greater than height: {}'
                             .format(pos_.y, self.height))
        return self.v_from_xy_(pos_)
    
    cdef a_t v_from_xy_(self, vec2 pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        Given a position between indices, will return a weighted
        average of the pixels stored around the passed position.
        :param pos: pos
        :return: int
        """
        if not 0 <= pos.x <= self.width - 1:
            raise ValueError('x ({}) outside valid range'.format(pos.x))
        if not 0 <= pos.y <= self.height - 1:
            raise ValueError('y ({}) outside valid range'.format(pos.x))
        return self.sample(pos)
    
    cpdef a_t v_from_rel_xy(self, tuple pos) except? -1.:
        """
        Returns value stored for passed x, y position in TextureMap data.
        :param pos x, y int or float
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos[0] < 1, pos[0]
            assert 0 <= pos[1] < 1, pos[1]
        cdef vec2 pos_ = cp2v_2d(pos)
        return self.v_from_rel_xy_(pos_)
    
    cdef a_t v_from_rel_xy_(self, vec2 pos) except? -1.:
        """
        Gets value stored for passed x, y position in TextureMap data.
        :param pos x, y floats in range (0-1) inclusive
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos.x <= 1, pos.x
            assert 0 <= pos.y <= 1, pos.y
        cdef vec2 abs_pos
        abs_pos.x = pos.x * (self.width - 1)
        abs_pos.y = pos.y * (self.height - 1)
        IF ASSERTS:
            assert 0 <= abs_pos.x <= self.width
            assert 0 <= abs_pos.y <= self.height
        return self.v_from_xy_(abs_pos)
    
    cdef a_t v_from_xy_indices_(self, int[2] pos) except? -1.:
        """
        Gets value stored in data array at passed x, y indices.
        :param pos int x, int y
        """
        IF ASSERTS:
            assert 0 <= pos[0] <= self.width - 1, \
                f'{pos[0]} outside width range 0 - {self.width - 1}'
            assert 0 <= pos[1] <= self.height - 1, \
                f'{pos[1]} outside height range 0 - {self.height - 1}'
    
        return (<a_t *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef a_t v_from_vector(self, vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef a_t v_from_vector_(self, vec3 vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_xy_(self.xy_from_vector_(vector))
    
    cpdef object gradient_from_xy(self, tuple[double] pos):
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y int or floats
        :return mathutils.Vector
        """
        cdef vec2 gr
        cdef vec2 pos_ = cp2v_2d(pos)
        gr = self.gradient_from_xy_(pos_)
        return Vector((gr.x, gr.y))
    
    @cython.cdivision(True)
    cdef vec2 gradient_from_xy_(self, vec2 pos) except *:
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y doubles
        :return vec2
        """
        cdef int[2] p0, p1, p2, p3  # four sampled positions
        cdef a_t v0, v1, v2, v3  # four sampled values
        cdef vec2 gr  # gradient
        self._sample_pos(p0, p1, p2, p3, pos)
        if p0[0] == -1:
            # if no fourth quadrant exists for the passed position
            v1 = self.v_from_xy_indices_(p0)
            v2 = self.v_from_xy_indices_(p1)
            v3 = self.v_from_xy_indices_(p2)
            gr.x = float(v3 - v2)
            gr.y = float(v1 - v2)
        else:
            # otherwise, if four positions are available to be sampled..
            v0 = self.v_from_xy_indices_(p0)
            v1 = self.v_from_xy_indices_(p1)
            v2 = self.v_from_xy_indices_(p2)
            v3 = self.v_from_xy_indices_(p3)
            # find gradient
            gr.x = float((v0 + v3) - (v1 + v2)) / 2  # x v of gradient vector
            gr.y = float((v0 + v1) - (v2 + v3)) / 2  # y v of gradient vector
        return gr
    
    cdef inline void _sample_pos(
            self,
            int[2] p0,
            int[2] p1,
            int[2] p2,
            int[2] p3,
            vec2 pos):
        """
        Gets indices of map that contain information relevant to passed
        double position.
        p3 may be given a value of (-1, -1) indicating that it does not
        exist (for example; if passed position is located where
        geometry folds, such as a cube's corner)
        """
        p2[0] = <int>pos.x
        p2[1] = <int>pos.y
        self.r_px_(p3, p2)
        self.u_px_(p1, p2)
        self.ur_px_(p0, p2)
    
    cdef inline void r_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel right of the passed position
        """
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1]
        # no return value, result stored in new_pos mem_view
    
    cdef inline void u_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel down of the passed position
        """
        new_pos[0] = old_pos[0]
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    cdef inline void ur_px_(self, int[2] new_pos, int[2] old_pos):
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    @cython.cdivision(True)
    cdef double gauss_smooth_xy_(
            self, vec2 pos, double radius, int samples) except -1.:
        # Should never return a negative normally.
        """
        Gets the gaussian smoothed value for the passed position,
        using the passed radius and number of sample positions
        Passed radius is in pixels
        """
        cdef vec3 pos_vector  # vector identifying passed position
        cdef vec3 point_vector  # vector identifying sampled point
        cdef vec3 polar_vector = mu.vec3New(0, 0, 1)
        cdef mat3x3 rotation  # rotation matrix
        if samples < 1:
            raise ValueError('Samples must be >= 1. Got: {}'.format(samples))
        pos_vector = self.vector_from_xy_(pos)
        mu.rotation_difference(rotation, polar_vector, pos_vector)
        cdef double sum = 0.
        cdef double v
        cdef latlon ll
        for i in range(samples):
            ll.lon = i / samples * TAU - PI
            IF ASSERTS:
                assert MIN_LON <= ll.lon <= MAX_LON, ll.lon
            for j in range(samples):
                ll.lat = MAX_LAT - MAX_LAT / self.height / samples * radius * j
                IF ASSERTS:
                    assert MIN_LAT <= ll.lat <= MAX_LAT, ll.lat
                point_vector = vector_from_lat_lon_(ll)
                point_vector = mu.mat3x3MultiplyVector(rotation, point_vector)
                IF ASSERTS:
                     # check that values have been set
                    assert point_vector.x != 0 or \
                        point_vector.y != 0 or \
                        point_vector.z != 0, \
                        'v: {}, ll: {}'.format(point_vector, ll)
                v = self.v_from_vector_(point_vector)
                IF ASSERTS:
                    assert v >= 0, v
                sum += v
        IF ASSERTS:
            assert sum >= 0, sum
        sum /= samples * samples
        IF ASSERTS:
            assert sum >= 0, "sum: " + str(sum)
        return sum
    
    cpdef void set_xy(self, pos, v) except *:
        cdef int[2] pos_
        pos_[0] = <int>pos[0]
        pos_[1] = <int>pos[1]
        if not 0 <= pos_[0] < self.width:
            raise ValueError('Width {} outside range 0 - {}'
                             .format(pos_[0], self.width))
        if not 0 <= pos_[1] < self.height:
            raise ValueError('Height {} outside range 0 - {}'
                             .format(pos_[1], self.height))
        self.set_xy_(pos_, v)
    
    cdef void set_xy_(self, int[2] pos, a_t v) nogil except *:
        (<a_t *> self._arr)[pos[1] * self.width + pos[0]] = v
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef a_t sample(self, vec2 pos) nogil except? -1.:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef a_t left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef a_t *arr = <a_t *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = left1 * b_mod + left0 * (1 - b_mod)
            right0 = right1 * b_mod + right0 * (1 - b_mod)
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = left1 * b_mod + left0 * (1 - b_mod)
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    
    @cython.cdivision(True)
    @cython.wraparound(False)
    cpdef void write_png(self, unicode out) except *:
        """
        Writes map as a png to the passed path.
        :param out: path String
        :return: None
        """
        cdef float max = 64, min = 0
        cdef int x, y
        cdef float v
        cdef int[2] pos
        cdef np.ndarray out_arr
        if '.' not in out:
            out += '.png'  # adjust out path
        while True:
            # try to get array to print. if a value is outside range,
            # start over and increase max.
            # this lets us see a map that is scaled to fit the t range
            # of a planet.
            restart = False  # reset flag
            out_arr = np.ndarray((self.height, self.width), np.uint8)
            for y in range(self.height):
                pos[1] = y
                for x in range(self.width):
                    pos[0] = x
                    v = self.v_from_xy_indices_(pos)
                    if v > max:
                        # increase max
                        max = 2 ** ceil(log2(v))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    if v < min:
                        # decrease min
                        min = -(2 ** ceil(log2(abs(v))))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    out_v = (v - min) * 255 / (max - min)
                    IF ASSERTS:
                        assert 0 <= out_v < 256, f'{x},{y}: {out_v}'
                    out_arr[y][x] = out_v
                if restart:
                    break
            if not restart:
                break
    
        with open(out, 'wb') as f:
            height = len(out_arr)
            width = len(out_arr[0])
            w = png.Writer(width, height, greyscale=True)
            w.write(f, out_arr)
    

cdef class GreyLatLonMap(LatLonMap):
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(a_t))
    
    cpdef void load_arr(self, unicode path) except *:
        cdef np.ndarray arr
    
        arr = np.load(path, allow_pickle=False)
    
        # validate data
        if not arr.dtype == np.float32:
            raise TypeError(
                f'Loaded arr had wrong data type. Got: {arr.dtype} '
                f'Expected: float32'
            )
    
        if not len(arr) == self.height:
            raise ValueError(
                f'Passed array of unexpected height. Got: {len(arr)}, '
                f'expected {self.height}'
            )
    
        if not len(arr[0]) == self.width:
            raise ValueError(
                f'Passed array of unexpected width. Got: {len(arr[1])}, '
                f'expected {self.width}'
            )
    
        # transfer values
        for y in range(self.height):
            for x in range(self.width):
                (<a_t *>self._arr)[y * self.width + x] = arr[y, x]
    
    cpdef void save(self, unicode path) except *:
        n_arr = np.ndarray((self.height, self.width), dtype=np.float32)
    
        # populate numpy arr
        for y in range(self.height):
            for x in range(self.width):
                n_arr[y, x] = (<a_t *>self._arr)[y * self.width + x]
    
        np.save(path, n_arr, allow_pickle=False)
        
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, GreyCubeMap):
            self.clone_(<GreyCubeMap> p)
        elif isinstance(p, GreyLatLonMap):
            self.clone_(<GreyLatLonMap> p)
        elif isinstance(p, GreyTileMap):
            self.clone_(<GreyTileMap> p)
        elif isinstance(p, GreyCubeSide):
            self.clone_(<GreyCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, grey_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef a_t v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    cpdef a_t v_from_lat_lon(self, pos) except? -1.:
        """
        Gets pixel value at passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: a_t
        """
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef a_t v_from_lat_lon_(self, latlon pos) except? -1.:
        """
        Gets value stored for passed latitude, longitude
        :param pos lat, lon
        :return int
        """
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef a_t v_from_xy(self, pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        :param pos: pos
        :return int
        """
        cdef vec2 pos_ = cp2v_2d(pos)
        if not 0 <= pos_.x < self.width:
            raise ValueError('x value: {} was greater than width: {}'
                             .format(pos_.x, self.width))
        if not 0 <= pos_.y < self.height:
            raise ValueError('y value: {} was greater than height: {}'
                             .format(pos_.y, self.height))
        return self.v_from_xy_(pos_)
    
    cdef a_t v_from_xy_(self, vec2 pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        Given a position between indices, will return a weighted
        average of the pixels stored around the passed position.
        :param pos: pos
        :return: int
        """
        if not 0 <= pos.x <= self.width - 1:
            raise ValueError('x ({}) outside valid range'.format(pos.x))
        if not 0 <= pos.y <= self.height - 1:
            raise ValueError('y ({}) outside valid range'.format(pos.x))
        return self.sample(pos)
    
    cpdef a_t v_from_rel_xy(self, tuple pos) except? -1.:
        """
        Returns value stored for passed x, y position in TextureMap data.
        :param pos x, y int or float
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos[0] < 1, pos[0]
            assert 0 <= pos[1] < 1, pos[1]
        cdef vec2 pos_ = cp2v_2d(pos)
        return self.v_from_rel_xy_(pos_)
    
    cdef a_t v_from_rel_xy_(self, vec2 pos) except? -1.:
        """
        Gets value stored for passed x, y position in TextureMap data.
        :param pos x, y floats in range (0-1) inclusive
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos.x <= 1, pos.x
            assert 0 <= pos.y <= 1, pos.y
        cdef vec2 abs_pos
        abs_pos.x = pos.x * (self.width - 1)
        abs_pos.y = pos.y * (self.height - 1)
        IF ASSERTS:
            assert 0 <= abs_pos.x <= self.width
            assert 0 <= abs_pos.y <= self.height
        return self.v_from_xy_(abs_pos)
    
    cdef a_t v_from_xy_indices_(self, int[2] pos) except? -1.:
        """
        Gets value stored in data array at passed x, y indices.
        :param pos int x, int y
        """
        IF ASSERTS:
            assert 0 <= pos[0] <= self.width - 1, \
                f'{pos[0]} outside width range 0 - {self.width - 1}'
            assert 0 <= pos[1] <= self.height - 1, \
                f'{pos[1]} outside height range 0 - {self.height - 1}'
    
        return (<a_t *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef a_t v_from_vector(self, vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef a_t v_from_vector_(self, vec3 vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_xy_(self.xy_from_vector_(vector))
    
    cpdef object gradient_from_xy(self, tuple[double] pos):
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y int or floats
        :return mathutils.Vector
        """
        cdef vec2 gr
        cdef vec2 pos_ = cp2v_2d(pos)
        gr = self.gradient_from_xy_(pos_)
        return Vector((gr.x, gr.y))
    
    @cython.cdivision(True)
    cdef vec2 gradient_from_xy_(self, vec2 pos) except *:
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y doubles
        :return vec2
        """
        cdef int[2] p0, p1, p2, p3  # four sampled positions
        cdef a_t v0, v1, v2, v3  # four sampled values
        cdef vec2 gr  # gradient
        self._sample_pos(p0, p1, p2, p3, pos)
        if p0[0] == -1:
            # if no fourth quadrant exists for the passed position
            v1 = self.v_from_xy_indices_(p0)
            v2 = self.v_from_xy_indices_(p1)
            v3 = self.v_from_xy_indices_(p2)
            gr.x = float(v3 - v2)
            gr.y = float(v1 - v2)
        else:
            # otherwise, if four positions are available to be sampled..
            v0 = self.v_from_xy_indices_(p0)
            v1 = self.v_from_xy_indices_(p1)
            v2 = self.v_from_xy_indices_(p2)
            v3 = self.v_from_xy_indices_(p3)
            # find gradient
            gr.x = float((v0 + v3) - (v1 + v2)) / 2  # x v of gradient vector
            gr.y = float((v0 + v1) - (v2 + v3)) / 2  # y v of gradient vector
        return gr
    
    cdef inline void _sample_pos(
            self,
            int[2] p0,
            int[2] p1,
            int[2] p2,
            int[2] p3,
            vec2 pos):
        """
        Gets indices of map that contain information relevant to passed
        double position.
        p3 may be given a value of (-1, -1) indicating that it does not
        exist (for example; if passed position is located where
        geometry folds, such as a cube's corner)
        """
        p2[0] = <int>pos.x
        p2[1] = <int>pos.y
        self.r_px_(p3, p2)
        self.u_px_(p1, p2)
        self.ur_px_(p0, p2)
    
    cdef inline void r_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel right of the passed position
        """
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1]
        # no return value, result stored in new_pos mem_view
    
    cdef inline void u_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel down of the passed position
        """
        new_pos[0] = old_pos[0]
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    cdef inline void ur_px_(self, int[2] new_pos, int[2] old_pos):
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    @cython.cdivision(True)
    cdef double gauss_smooth_xy_(
            self, vec2 pos, double radius, int samples) except -1.:
        # Should never return a negative normally.
        """
        Gets the gaussian smoothed value for the passed position,
        using the passed radius and number of sample positions
        Passed radius is in pixels
        """
        cdef vec3 pos_vector  # vector identifying passed position
        cdef vec3 point_vector  # vector identifying sampled point
        cdef vec3 polar_vector = mu.vec3New(0, 0, 1)
        cdef mat3x3 rotation  # rotation matrix
        if samples < 1:
            raise ValueError('Samples must be >= 1. Got: {}'.format(samples))
        pos_vector = self.vector_from_xy_(pos)
        mu.rotation_difference(rotation, polar_vector, pos_vector)
        cdef double sum = 0.
        cdef double v
        cdef latlon ll
        for i in range(samples):
            ll.lon = i / samples * TAU - PI
            IF ASSERTS:
                assert MIN_LON <= ll.lon <= MAX_LON, ll.lon
            for j in range(samples):
                ll.lat = MAX_LAT - MAX_LAT / self.height / samples * radius * j
                IF ASSERTS:
                    assert MIN_LAT <= ll.lat <= MAX_LAT, ll.lat
                point_vector = vector_from_lat_lon_(ll)
                point_vector = mu.mat3x3MultiplyVector(rotation, point_vector)
                IF ASSERTS:
                     # check that values have been set
                    assert point_vector.x != 0 or \
                        point_vector.y != 0 or \
                        point_vector.z != 0, \
                        'v: {}, ll: {}'.format(point_vector, ll)
                v = self.v_from_vector_(point_vector)
                IF ASSERTS:
                    assert v >= 0, v
                sum += v
        IF ASSERTS:
            assert sum >= 0, sum
        sum /= samples * samples
        IF ASSERTS:
            assert sum >= 0, "sum: " + str(sum)
        return sum
    
    cpdef void set_xy(self, pos, v) except *:
        cdef int[2] pos_
        pos_[0] = <int>pos[0]
        pos_[1] = <int>pos[1]
        if not 0 <= pos_[0] < self.width:
            raise ValueError('Width {} outside range 0 - {}'
                             .format(pos_[0], self.width))
        if not 0 <= pos_[1] < self.height:
            raise ValueError('Height {} outside range 0 - {}'
                             .format(pos_[1], self.height))
        self.set_xy_(pos_, v)
    
    cdef void set_xy_(self, int[2] pos, a_t v) nogil except *:
        (<a_t *> self._arr)[pos[1] * self.width + pos[0]] = v
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef a_t sample(self, vec2 pos) nogil except? -1.:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef a_t left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef a_t *arr = <a_t *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = left1 * b_mod + left0 * (1 - b_mod)
            right0 = right1 * b_mod + right0 * (1 - b_mod)
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = left1 * b_mod + left0 * (1 - b_mod)
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    
    @cython.cdivision(True)
    @cython.wraparound(False)
    cpdef void write_png(self, unicode out) except *:
        """
        Writes map as a png to the passed path.
        :param out: path String
        :return: None
        """
        cdef float max = 64, min = 0
        cdef int x, y
        cdef float v
        cdef int[2] pos
        cdef np.ndarray out_arr
        if '.' not in out:
            out += '.png'  # adjust out path
        while True:
            # try to get array to print. if a value is outside range,
            # start over and increase max.
            # this lets us see a map that is scaled to fit the t range
            # of a planet.
            restart = False  # reset flag
            out_arr = np.ndarray((self.height, self.width), np.uint8)
            for y in range(self.height):
                pos[1] = y
                for x in range(self.width):
                    pos[0] = x
                    v = self.v_from_xy_indices_(pos)
                    if v > max:
                        # increase max
                        max = 2 ** ceil(log2(v))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    if v < min:
                        # decrease min
                        min = -(2 ** ceil(log2(abs(v))))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    out_v = (v - min) * 255 / (max - min)
                    IF ASSERTS:
                        assert 0 <= out_v < 256, f'{x},{y}: {out_v}'
                    out_arr[y][x] = out_v
                if restart:
                    break
            if not restart:
                break
    
        with open(out, 'wb') as f:
            height = len(out_arr)
            width = len(out_arr[0])
            w = png.Writer(width, height, greyscale=True)
            w.write(f, out_arr)
    

cdef class GreyTileMap(TileMap):
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(a_t))
    
    cpdef void load_arr(self, unicode path) except *:
        cdef np.ndarray arr
    
        arr = np.load(path, allow_pickle=False)
    
        # validate data
        if not arr.dtype == np.float32:
            raise TypeError(
                f'Loaded arr had wrong data type. Got: {arr.dtype} '
                f'Expected: float32'
            )
    
        if not len(arr) == self.height:
            raise ValueError(
                f'Passed array of unexpected height. Got: {len(arr)}, '
                f'expected {self.height}'
            )
    
        if not len(arr[0]) == self.width:
            raise ValueError(
                f'Passed array of unexpected width. Got: {len(arr[1])}, '
                f'expected {self.width}'
            )
    
        # transfer values
        for y in range(self.height):
            for x in range(self.width):
                (<a_t *>self._arr)[y * self.width + x] = arr[y, x]
    
    cpdef void save(self, unicode path) except *:
        n_arr = np.ndarray((self.height, self.width), dtype=np.float32)
    
        # populate numpy arr
        for y in range(self.height):
            for x in range(self.width):
                n_arr[y, x] = (<a_t *>self._arr)[y * self.width + x]
    
        np.save(path, n_arr, allow_pickle=False)
        
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, GreyCubeMap):
            self.clone_(<GreyCubeMap> p)
        elif isinstance(p, GreyLatLonMap):
            self.clone_(<GreyLatLonMap> p)
        elif isinstance(p, GreyTileMap):
            self.clone_(<GreyTileMap> p)
        elif isinstance(p, GreyCubeSide):
            self.clone_(<GreyCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, grey_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef a_t v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    cpdef a_t v_from_lat_lon(self, pos) except? -1.:
        """
        Gets pixel value at passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: a_t
        """
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef a_t v_from_lat_lon_(self, latlon pos) except? -1.:
        """
        Gets value stored for passed latitude, longitude
        :param pos lat, lon
        :return int
        """
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef a_t v_from_xy(self, pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        :param pos: pos
        :return int
        """
        cdef vec2 pos_ = cp2v_2d(pos)
        if not 0 <= pos_.x < self.width:
            raise ValueError('x value: {} was greater than width: {}'
                             .format(pos_.x, self.width))
        if not 0 <= pos_.y < self.height:
            raise ValueError('y value: {} was greater than height: {}'
                             .format(pos_.y, self.height))
        return self.v_from_xy_(pos_)
    
    cdef a_t v_from_xy_(self, vec2 pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        Given a position between indices, will return a weighted
        average of the pixels stored around the passed position.
        :param pos: pos
        :return: int
        """
        if not 0 <= pos.x <= self.width - 1:
            raise ValueError('x ({}) outside valid range'.format(pos.x))
        if not 0 <= pos.y <= self.height - 1:
            raise ValueError('y ({}) outside valid range'.format(pos.x))
        return self.sample(pos)
    
    cpdef a_t v_from_rel_xy(self, tuple pos) except? -1.:
        """
        Returns value stored for passed x, y position in TextureMap data.
        :param pos x, y int or float
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos[0] < 1, pos[0]
            assert 0 <= pos[1] < 1, pos[1]
        cdef vec2 pos_ = cp2v_2d(pos)
        return self.v_from_rel_xy_(pos_)
    
    cdef a_t v_from_rel_xy_(self, vec2 pos) except? -1.:
        """
        Gets value stored for passed x, y position in TextureMap data.
        :param pos x, y floats in range (0-1) inclusive
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos.x <= 1, pos.x
            assert 0 <= pos.y <= 1, pos.y
        cdef vec2 abs_pos
        abs_pos.x = pos.x * (self.width - 1)
        abs_pos.y = pos.y * (self.height - 1)
        IF ASSERTS:
            assert 0 <= abs_pos.x <= self.width
            assert 0 <= abs_pos.y <= self.height
        return self.v_from_xy_(abs_pos)
    
    cdef a_t v_from_xy_indices_(self, int[2] pos) except? -1.:
        """
        Gets value stored in data array at passed x, y indices.
        :param pos int x, int y
        """
        IF ASSERTS:
            assert 0 <= pos[0] <= self.width - 1, \
                f'{pos[0]} outside width range 0 - {self.width - 1}'
            assert 0 <= pos[1] <= self.height - 1, \
                f'{pos[1]} outside height range 0 - {self.height - 1}'
    
        return (<a_t *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef a_t v_from_vector(self, vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef a_t v_from_vector_(self, vec3 vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_xy_(self.xy_from_vector_(vector))
    
    cpdef object gradient_from_xy(self, tuple[double] pos):
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y int or floats
        :return mathutils.Vector
        """
        cdef vec2 gr
        cdef vec2 pos_ = cp2v_2d(pos)
        gr = self.gradient_from_xy_(pos_)
        return Vector((gr.x, gr.y))
    
    @cython.cdivision(True)
    cdef vec2 gradient_from_xy_(self, vec2 pos) except *:
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y doubles
        :return vec2
        """
        cdef int[2] p0, p1, p2, p3  # four sampled positions
        cdef a_t v0, v1, v2, v3  # four sampled values
        cdef vec2 gr  # gradient
        self._sample_pos(p0, p1, p2, p3, pos)
        if p0[0] == -1:
            # if no fourth quadrant exists for the passed position
            v1 = self.v_from_xy_indices_(p0)
            v2 = self.v_from_xy_indices_(p1)
            v3 = self.v_from_xy_indices_(p2)
            gr.x = float(v3 - v2)
            gr.y = float(v1 - v2)
        else:
            # otherwise, if four positions are available to be sampled..
            v0 = self.v_from_xy_indices_(p0)
            v1 = self.v_from_xy_indices_(p1)
            v2 = self.v_from_xy_indices_(p2)
            v3 = self.v_from_xy_indices_(p3)
            # find gradient
            gr.x = float((v0 + v3) - (v1 + v2)) / 2  # x v of gradient vector
            gr.y = float((v0 + v1) - (v2 + v3)) / 2  # y v of gradient vector
        return gr
    
    cdef inline void _sample_pos(
            self,
            int[2] p0,
            int[2] p1,
            int[2] p2,
            int[2] p3,
            vec2 pos):
        """
        Gets indices of map that contain information relevant to passed
        double position.
        p3 may be given a value of (-1, -1) indicating that it does not
        exist (for example; if passed position is located where
        geometry folds, such as a cube's corner)
        """
        p2[0] = <int>pos.x
        p2[1] = <int>pos.y
        self.r_px_(p3, p2)
        self.u_px_(p1, p2)
        self.ur_px_(p0, p2)
    
    cdef inline void r_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel right of the passed position
        """
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1]
        # no return value, result stored in new_pos mem_view
    
    cdef inline void u_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel down of the passed position
        """
        new_pos[0] = old_pos[0]
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    cdef inline void ur_px_(self, int[2] new_pos, int[2] old_pos):
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    @cython.cdivision(True)
    cdef double gauss_smooth_xy_(
            self, vec2 pos, double radius, int samples) except -1.:
        # Should never return a negative normally.
        """
        Gets the gaussian smoothed value for the passed position,
        using the passed radius and number of sample positions
        Passed radius is in pixels
        """
        cdef vec3 pos_vector  # vector identifying passed position
        cdef vec3 point_vector  # vector identifying sampled point
        cdef vec3 polar_vector = mu.vec3New(0, 0, 1)
        cdef mat3x3 rotation  # rotation matrix
        if samples < 1:
            raise ValueError('Samples must be >= 1. Got: {}'.format(samples))
        pos_vector = self.vector_from_xy_(pos)
        mu.rotation_difference(rotation, polar_vector, pos_vector)
        cdef double sum = 0.
        cdef double v
        cdef latlon ll
        for i in range(samples):
            ll.lon = i / samples * TAU - PI
            IF ASSERTS:
                assert MIN_LON <= ll.lon <= MAX_LON, ll.lon
            for j in range(samples):
                ll.lat = MAX_LAT - MAX_LAT / self.height / samples * radius * j
                IF ASSERTS:
                    assert MIN_LAT <= ll.lat <= MAX_LAT, ll.lat
                point_vector = vector_from_lat_lon_(ll)
                point_vector = mu.mat3x3MultiplyVector(rotation, point_vector)
                IF ASSERTS:
                     # check that values have been set
                    assert point_vector.x != 0 or \
                        point_vector.y != 0 or \
                        point_vector.z != 0, \
                        'v: {}, ll: {}'.format(point_vector, ll)
                v = self.v_from_vector_(point_vector)
                IF ASSERTS:
                    assert v >= 0, v
                sum += v
        IF ASSERTS:
            assert sum >= 0, sum
        sum /= samples * samples
        IF ASSERTS:
            assert sum >= 0, "sum: " + str(sum)
        return sum
    
    cpdef void set_xy(self, pos, v) except *:
        cdef int[2] pos_
        pos_[0] = <int>pos[0]
        pos_[1] = <int>pos[1]
        if not 0 <= pos_[0] < self.width:
            raise ValueError('Width {} outside range 0 - {}'
                             .format(pos_[0], self.width))
        if not 0 <= pos_[1] < self.height:
            raise ValueError('Height {} outside range 0 - {}'
                             .format(pos_[1], self.height))
        self.set_xy_(pos_, v)
    
    cdef void set_xy_(self, int[2] pos, a_t v) nogil except *:
        (<a_t *> self._arr)[pos[1] * self.width + pos[0]] = v
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef a_t sample(self, vec2 pos) nogil except? -1.:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef a_t left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef a_t *arr = <a_t *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = left1 * b_mod + left0 * (1 - b_mod)
            right0 = right1 * b_mod + right0 * (1 - b_mod)
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = left1 * b_mod + left0 * (1 - b_mod)
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    
    @cython.cdivision(True)
    @cython.wraparound(False)
    cpdef void write_png(self, unicode out) except *:
        """
        Writes map as a png to the passed path.
        :param out: path String
        :return: None
        """
        cdef float max = 64, min = 0
        cdef int x, y
        cdef float v
        cdef int[2] pos
        cdef np.ndarray out_arr
        if '.' not in out:
            out += '.png'  # adjust out path
        while True:
            # try to get array to print. if a value is outside range,
            # start over and increase max.
            # this lets us see a map that is scaled to fit the t range
            # of a planet.
            restart = False  # reset flag
            out_arr = np.ndarray((self.height, self.width), np.uint8)
            for y in range(self.height):
                pos[1] = y
                for x in range(self.width):
                    pos[0] = x
                    v = self.v_from_xy_indices_(pos)
                    if v > max:
                        # increase max
                        max = 2 ** ceil(log2(v))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    if v < min:
                        # decrease min
                        min = -(2 ** ceil(log2(abs(v))))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    out_v = (v - min) * 255 / (max - min)
                    IF ASSERTS:
                        assert 0 <= out_v < 256, f'{x},{y}: {out_v}'
                    out_arr[y][x] = out_v
                if restart:
                    break
            if not restart:
                break
    
        with open(out, 'wb') as f:
            height = len(out_arr)
            width = len(out_arr[0])
            w = png.Writer(width, height, greyscale=True)
            w.write(f, out_arr)
    

cdef class GreyCubeSide(CubeSide):
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(a_t))
    
    cpdef void load_arr(self, unicode path) except *:
        cdef np.ndarray arr
    
        arr = np.load(path, allow_pickle=False)
    
        # validate data
        if not arr.dtype == np.float32:
            raise TypeError(
                f'Loaded arr had wrong data type. Got: {arr.dtype} '
                f'Expected: float32'
            )
    
        if not len(arr) == self.height:
            raise ValueError(
                f'Passed array of unexpected height. Got: {len(arr)}, '
                f'expected {self.height}'
            )
    
        if not len(arr[0]) == self.width:
            raise ValueError(
                f'Passed array of unexpected width. Got: {len(arr[1])}, '
                f'expected {self.width}'
            )
    
        # transfer values
        for y in range(self.height):
            for x in range(self.width):
                (<a_t *>self._arr)[y * self.width + x] = arr[y, x]
    
    cpdef void save(self, unicode path) except *:
        n_arr = np.ndarray((self.height, self.width), dtype=np.float32)
    
        # populate numpy arr
        for y in range(self.height):
            for x in range(self.width):
                n_arr[y, x] = (<a_t *>self._arr)[y * self.width + x]
    
        np.save(path, n_arr, allow_pickle=False)
        
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, GreyCubeMap):
            self.clone_(<GreyCubeMap> p)
        elif isinstance(p, GreyLatLonMap):
            self.clone_(<GreyLatLonMap> p)
        elif isinstance(p, GreyTileMap):
            self.clone_(<GreyTileMap> p)
        elif isinstance(p, GreyCubeSide):
            self.clone_(<GreyCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, grey_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef a_t v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    cpdef a_t v_from_lat_lon(self, pos) except? -1.:
        """
        Gets pixel value at passed latitude and longitude.
        :param pos: tuple(lat, lon)
        :return: a_t
        """
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef a_t v_from_lat_lon_(self, latlon pos) except? -1.:
        """
        Gets value stored for passed latitude, longitude
        :param pos lat, lon
        :return int
        """
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef a_t v_from_xy(self, pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        :param pos: pos
        :return int
        """
        cdef vec2 pos_ = cp2v_2d(pos)
        if not 0 <= pos_.x < self.width:
            raise ValueError('x value: {} was greater than width: {}'
                             .format(pos_.x, self.width))
        if not 0 <= pos_.y < self.height:
            raise ValueError('y value: {} was greater than height: {}'
                             .format(pos_.y, self.height))
        return self.v_from_xy_(pos_)
    
    cdef a_t v_from_xy_(self, vec2 pos) except? -1.:
        """
        Gets pixel value at passed position on this map.
        Given a position between indices, will return a weighted
        average of the pixels stored around the passed position.
        :param pos: pos
        :return: int
        """
        if not 0 <= pos.x <= self.width - 1:
            raise ValueError('x ({}) outside valid range'.format(pos.x))
        if not 0 <= pos.y <= self.height - 1:
            raise ValueError('y ({}) outside valid range'.format(pos.x))
        return self.sample(pos)
    
    cpdef a_t v_from_rel_xy(self, tuple pos) except? -1.:
        """
        Returns value stored for passed x, y position in TextureMap data.
        :param pos x, y int or float
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos[0] < 1, pos[0]
            assert 0 <= pos[1] < 1, pos[1]
        cdef vec2 pos_ = cp2v_2d(pos)
        return self.v_from_rel_xy_(pos_)
    
    cdef a_t v_from_rel_xy_(self, vec2 pos) except? -1.:
        """
        Gets value stored for passed x, y position in TextureMap data.
        :param pos x, y floats in range (0-1) inclusive
        :return int
        """
        IF ASSERTS:
            assert 0 <= pos.x <= 1, pos.x
            assert 0 <= pos.y <= 1, pos.y
        cdef vec2 abs_pos
        abs_pos.x = pos.x * (self.width - 1)
        abs_pos.y = pos.y * (self.height - 1)
        IF ASSERTS:
            assert 0 <= abs_pos.x <= self.width
            assert 0 <= abs_pos.y <= self.height
        return self.v_from_xy_(abs_pos)
    
    cdef a_t v_from_xy_indices_(self, int[2] pos) except? -1.:
        """
        Gets value stored in data array at passed x, y indices.
        :param pos int x, int y
        """
        IF ASSERTS:
            assert 0 <= pos[0] <= self.width - 1, \
                f'{pos[0]} outside width range 0 - {self.width - 1}'
            assert 0 <= pos[1] <= self.height - 1, \
                f'{pos[1]} outside height range 0 - {self.height - 1}'
    
        return (<a_t *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef a_t v_from_vector(self, vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef a_t v_from_vector_(self, vec3 vector) except? -1.:
        """
        Gets pixel value identified by vector.
        :param vector: vec3
        :return int
        """
        return self.v_from_xy_(self.xy_from_vector_(vector))
    
    cpdef object gradient_from_xy(self, tuple[double] pos):
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y int or floats
        :return mathutils.Vector
        """
        cdef vec2 gr
        cdef vec2 pos_ = cp2v_2d(pos)
        gr = self.gradient_from_xy_(pos_)
        return Vector((gr.x, gr.y))
    
    @cython.cdivision(True)
    cdef vec2 gradient_from_xy_(self, vec2 pos) except *:
        """
        Gets gradient of map as a vec2 at passed position.
        :param pos x, y doubles
        :return vec2
        """
        cdef int[2] p0, p1, p2, p3  # four sampled positions
        cdef a_t v0, v1, v2, v3  # four sampled values
        cdef vec2 gr  # gradient
        self._sample_pos(p0, p1, p2, p3, pos)
        if p0[0] == -1:
            # if no fourth quadrant exists for the passed position
            v1 = self.v_from_xy_indices_(p0)
            v2 = self.v_from_xy_indices_(p1)
            v3 = self.v_from_xy_indices_(p2)
            gr.x = float(v3 - v2)
            gr.y = float(v1 - v2)
        else:
            # otherwise, if four positions are available to be sampled..
            v0 = self.v_from_xy_indices_(p0)
            v1 = self.v_from_xy_indices_(p1)
            v2 = self.v_from_xy_indices_(p2)
            v3 = self.v_from_xy_indices_(p3)
            # find gradient
            gr.x = float((v0 + v3) - (v1 + v2)) / 2  # x v of gradient vector
            gr.y = float((v0 + v1) - (v2 + v3)) / 2  # y v of gradient vector
        return gr
    
    cdef inline void _sample_pos(
            self,
            int[2] p0,
            int[2] p1,
            int[2] p2,
            int[2] p3,
            vec2 pos):
        """
        Gets indices of map that contain information relevant to passed
        double position.
        p3 may be given a value of (-1, -1) indicating that it does not
        exist (for example; if passed position is located where
        geometry folds, such as a cube's corner)
        """
        p2[0] = <int>pos.x
        p2[1] = <int>pos.y
        self.r_px_(p3, p2)
        self.u_px_(p1, p2)
        self.ur_px_(p0, p2)
    
    cdef inline void r_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel right of the passed position
        """
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1]
        # no return value, result stored in new_pos mem_view
    
    cdef inline void u_px_(self, int[2] new_pos, int[2] old_pos):
        """
        Returns position 1 map pixel down of the passed position
        """
        new_pos[0] = old_pos[0]
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    cdef inline void ur_px_(self, int[2] new_pos, int[2] old_pos):
        new_pos[0] = old_pos[0] + 1
        new_pos[1] = old_pos[1] + 1
        # no return value, result stored in new_pos mem_view
    
    @cython.cdivision(True)
    cdef double gauss_smooth_xy_(
            self, vec2 pos, double radius, int samples) except -1.:
        # Should never return a negative normally.
        """
        Gets the gaussian smoothed value for the passed position,
        using the passed radius and number of sample positions
        Passed radius is in pixels
        """
        cdef vec3 pos_vector  # vector identifying passed position
        cdef vec3 point_vector  # vector identifying sampled point
        cdef vec3 polar_vector = mu.vec3New(0, 0, 1)
        cdef mat3x3 rotation  # rotation matrix
        if samples < 1:
            raise ValueError('Samples must be >= 1. Got: {}'.format(samples))
        pos_vector = self.vector_from_xy_(pos)
        mu.rotation_difference(rotation, polar_vector, pos_vector)
        cdef double sum = 0.
        cdef double v
        cdef latlon ll
        for i in range(samples):
            ll.lon = i / samples * TAU - PI
            IF ASSERTS:
                assert MIN_LON <= ll.lon <= MAX_LON, ll.lon
            for j in range(samples):
                ll.lat = MAX_LAT - MAX_LAT / self.height / samples * radius * j
                IF ASSERTS:
                    assert MIN_LAT <= ll.lat <= MAX_LAT, ll.lat
                point_vector = vector_from_lat_lon_(ll)
                point_vector = mu.mat3x3MultiplyVector(rotation, point_vector)
                IF ASSERTS:
                     # check that values have been set
                    assert point_vector.x != 0 or \
                        point_vector.y != 0 or \
                        point_vector.z != 0, \
                        'v: {}, ll: {}'.format(point_vector, ll)
                v = self.v_from_vector_(point_vector)
                IF ASSERTS:
                    assert v >= 0, v
                sum += v
        IF ASSERTS:
            assert sum >= 0, sum
        sum /= samples * samples
        IF ASSERTS:
            assert sum >= 0, "sum: " + str(sum)
        return sum
    
    cpdef void set_xy(self, pos, v) except *:
        cdef int[2] pos_
        pos_[0] = <int>pos[0]
        pos_[1] = <int>pos[1]
        if not 0 <= pos_[0] < self.width:
            raise ValueError('Width {} outside range 0 - {}'
                             .format(pos_[0], self.width))
        if not 0 <= pos_[1] < self.height:
            raise ValueError('Height {} outside range 0 - {}'
                             .format(pos_[1], self.height))
        self.set_xy_(pos_, v)
    
    cdef void set_xy_(self, int[2] pos, a_t v) nogil except *:
        (<a_t *> self._arr)[pos[1] * self.width + pos[0]] = v
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef a_t sample(self, vec2 pos) nogil except? -1.:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef a_t left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef a_t *arr = <a_t *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = left1 * b_mod + left0 * (1 - b_mod)
            right0 = right1 * b_mod + right0 * (1 - b_mod)
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = right0 * a_mod + left0 * (1 - a_mod)
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = left1 * b_mod + left0 * (1 - b_mod)
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    
    @cython.cdivision(True)
    @cython.wraparound(False)
    cpdef void write_png(self, unicode out) except *:
        """
        Writes map as a png to the passed path.
        :param out: path String
        :return: None
        """
        cdef float max = 64, min = 0
        cdef int x, y
        cdef float v
        cdef int[2] pos
        cdef np.ndarray out_arr
        if '.' not in out:
            out += '.png'  # adjust out path
        while True:
            # try to get array to print. if a value is outside range,
            # start over and increase max.
            # this lets us see a map that is scaled to fit the t range
            # of a planet.
            restart = False  # reset flag
            out_arr = np.ndarray((self.height, self.width), np.uint8)
            for y in range(self.height):
                pos[1] = y
                for x in range(self.width):
                    pos[0] = x
                    v = self.v_from_xy_indices_(pos)
                    if v > max:
                        # increase max
                        max = 2 ** ceil(log2(v))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    if v < min:
                        # decrease min
                        min = -(2 ** ceil(log2(abs(v))))
                        # awkwardly use flag to break nested loop
                        restart = True
                        break
                    out_v = (v - min) * 255 / (max - min)
                    IF ASSERTS:
                        assert 0 <= out_v < 256, f'{x},{y}: {out_v}'
                    out_arr[y][x] = out_v
                if restart:
                    break
            if not restart:
                break
    
        with open(out, 'wb') as f:
            height = len(out_arr)
            width = len(out_arr[0])
            w = png.Writer(width, height, greyscale=True)
            w.write(f, out_arr)
    


#######################################################################
# VECTOR MAPS
#######################################################################


cdef class VecCubeMap(CubeMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(av))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, VecCubeMap):
            self.clone_(<VecCubeMap> p)
        elif isinstance(p, VecLatLonMap):
            self.clone_(<VecLatLonMap> p)
        elif isinstance(p, VecTileMap):
            self.clone_(<VecTileMap> p)
        elif isinstance(p, VecCubeSide):
            self.clone_(<VecCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, vec_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef av v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef av v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef av v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef av v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef av v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef av v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef av v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef av v_from_xy_indices_(self, int[2] pos) except *:
        return (<av *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef av v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef av v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, vec) except *:
        cdef int[2] pos_
        cdef av vec_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        vec_.x = vec[0]
        vec_.y = vec[1]
        self.set_xy_(pos_, vec_)
    
    cdef void set_xy_(self, int[2] pos, av vec) nogil except *:
        (<av *> self._arr)[pos[1] * self.width + pos[0]] = vec
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef av sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef av left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef av *arr = <av *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_av_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_av_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_av_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class VecLatLonMap(LatLonMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(av))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, VecCubeMap):
            self.clone_(<VecCubeMap> p)
        elif isinstance(p, VecLatLonMap):
            self.clone_(<VecLatLonMap> p)
        elif isinstance(p, VecTileMap):
            self.clone_(<VecTileMap> p)
        elif isinstance(p, VecCubeSide):
            self.clone_(<VecCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, vec_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef av v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef av v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef av v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef av v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef av v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef av v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef av v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef av v_from_xy_indices_(self, int[2] pos) except *:
        return (<av *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef av v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef av v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, vec) except *:
        cdef int[2] pos_
        cdef av vec_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        vec_.x = vec[0]
        vec_.y = vec[1]
        self.set_xy_(pos_, vec_)
    
    cdef void set_xy_(self, int[2] pos, av vec) nogil except *:
        (<av *> self._arr)[pos[1] * self.width + pos[0]] = vec
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef av sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef av left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef av *arr = <av *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_av_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_av_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_av_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class VecTileMap(TileMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(av))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, VecCubeMap):
            self.clone_(<VecCubeMap> p)
        elif isinstance(p, VecLatLonMap):
            self.clone_(<VecLatLonMap> p)
        elif isinstance(p, VecTileMap):
            self.clone_(<VecTileMap> p)
        elif isinstance(p, VecCubeSide):
            self.clone_(<VecCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, vec_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef av v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef av v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef av v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef av v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef av v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef av v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef av v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef av v_from_xy_indices_(self, int[2] pos) except *:
        return (<av *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef av v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef av v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, vec) except *:
        cdef int[2] pos_
        cdef av vec_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        vec_.x = vec[0]
        vec_.y = vec[1]
        self.set_xy_(pos_, vec_)
    
    cdef void set_xy_(self, int[2] pos, av vec) nogil except *:
        (<av *> self._arr)[pos[1] * self.width + pos[0]] = vec
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef av sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef av left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef av *arr = <av *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_av_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_av_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_av_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class VecCubeSide(CubeSide):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(av))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, VecCubeMap):
            self.clone_(<VecCubeMap> p)
        elif isinstance(p, VecLatLonMap):
            self.clone_(<VecLatLonMap> p)
        elif isinstance(p, VecTileMap):
            self.clone_(<VecTileMap> p)
        elif isinstance(p, VecCubeSide):
            self.clone_(<VecCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, vec_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef av v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef av v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef av v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef av v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef av v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef av v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef av v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef av v_from_xy_indices_(self, int[2] pos) except *:
        return (<av *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef av v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef av v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, vec) except *:
        cdef int[2] pos_
        cdef av vec_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        vec_.x = vec[0]
        vec_.y = vec[1]
        self.set_xy_(pos_, vec_)
    
    cdef void set_xy_(self, int[2] pos, av vec) nogil except *:
        (<av *> self._arr)[pos[1] * self.width + pos[0]] = vec
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef av sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef av left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef av *arr = <av *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_av_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_av_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_av_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_av_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    


#######################################################################
# REGION MAPS
#######################################################################


cdef class RegCubeMap(CubeMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(rt))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, RegCubeMap):
            self.clone_(<RegCubeMap> p)
        elif isinstance(p, RegLatLonMap):
            self.clone_(<RegLatLonMap> p)
        elif isinstance(p, RegTileMap):
            self.clone_(<RegTileMap> p)
        elif isinstance(p, RegCubeSide):
            self.clone_(<RegCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, reg_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef rt v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef rt v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef rt v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef rt v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef rt v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef rt v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef rt v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef rt v_from_xy_indices_(self, int[2] pos) except *:
        return (<rt *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef rt v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef rt v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, r) except *:
        cdef int[2] pos_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        self.set_xy_(pos_, r)
    
    cdef void set_xy_(self, int[2] pos, rt r) nogil except *:
        (<rt *> self._arr)[pos[1] * self.width + pos[0]] = r
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef rt sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef rt left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef rt *arr = <rt *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_region_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_region_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_region_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class RegLatLonMap(LatLonMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(rt))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, RegCubeMap):
            self.clone_(<RegCubeMap> p)
        elif isinstance(p, RegLatLonMap):
            self.clone_(<RegLatLonMap> p)
        elif isinstance(p, RegTileMap):
            self.clone_(<RegTileMap> p)
        elif isinstance(p, RegCubeSide):
            self.clone_(<RegCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, reg_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef rt v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef rt v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef rt v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef rt v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef rt v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef rt v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef rt v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef rt v_from_xy_indices_(self, int[2] pos) except *:
        return (<rt *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef rt v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef rt v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, r) except *:
        cdef int[2] pos_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        self.set_xy_(pos_, r)
    
    cdef void set_xy_(self, int[2] pos, rt r) nogil except *:
        (<rt *> self._arr)[pos[1] * self.width + pos[0]] = r
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef rt sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef rt left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef rt *arr = <rt *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_region_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_region_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_region_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class RegTileMap(TileMap):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(rt))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, RegCubeMap):
            self.clone_(<RegCubeMap> p)
        elif isinstance(p, RegLatLonMap):
            self.clone_(<RegLatLonMap> p)
        elif isinstance(p, RegTileMap):
            self.clone_(<RegTileMap> p)
        elif isinstance(p, RegCubeSide):
            self.clone_(<RegCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, reg_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef rt v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef rt v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef rt v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef rt v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef rt v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef rt v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef rt v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef rt v_from_xy_indices_(self, int[2] pos) except *:
        return (<rt *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef rt v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef rt v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, r) except *:
        cdef int[2] pos_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        self.set_xy_(pos_, r)
    
    cdef void set_xy_(self, int[2] pos, rt r) nogil except *:
        (<rt *> self._arr)[pos[1] * self.width + pos[0]] = r
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef rt sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef rt left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef rt *arr = <rt *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_region_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_region_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_region_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

cdef class RegCubeSide(CubeSide):
    
    
    cdef void _allocate_arr(self) except *:
        self._arr = malloc(self.width * self.height * sizeof(rt))
    
    cdef void clone(self, AbstractMap p) except *:
        if isinstance(p, RegCubeMap):
            self.clone_(<RegCubeMap> p)
        elif isinstance(p, RegLatLonMap):
            self.clone_(<RegLatLonMap> p)
        elif isinstance(p, RegTileMap):
            self.clone_(<RegTileMap> p)
        elif isinstance(p, RegCubeSide):
            self.clone_(<RegCubeSide> p)
        else:
            raise TypeError(f'Unexpected prototype map type: {p}')
    
    cdef void clone_(self, reg_map_t p) except *:
        cdef vec2 pos
        cdef vec3 vector
        cdef int[2] map_pos
        cdef rt v
        for x in range(self.width):
            for y in range(self.height):
                # get vector corresponding to position
                pos.x = x
                pos.y = y
                vector = self.vector_from_xy_(pos)
                v = p.v_from_vector_(vector)
                map_pos[0] = x
                map_pos[1] = y
                self.set_xy_(map_pos, v)
    
    # value retrieval methods
    cpdef rt v_from_lat_lon(self, pos) except *:
        return self.v_from_lat_lon_(cp2ll(pos))
    
    cdef rt v_from_lat_lon_(self, latlon pos) except *:
        return self.v_from_xy_(self.xy_from_lat_lon_(pos))
    
    cpdef rt v_from_xy(self, pos) except *:
        return self.v_from_xy_(cp2v_2d(pos))
    
    cdef rt v_from_xy_(self, vec2 pos) except *:
        return self.sample(pos)
    
    cpdef rt v_from_rel_xy(self, tuple pos) except *:
        return self.v_from_rel_xy_(cp2v_2d(pos))
    
    cdef rt v_from_rel_xy_(self, vec2 pos) except *:
        return self.v_from_xy_(self.xy_from_rel_xy_(pos))
    
    cdef rt v_from_xy_indices_(self, int[2] pos) except *:
        return (<rt *> self._arr)[pos[1] * self.width + pos[0]]
    
    cpdef rt v_from_vector(self, vector) except *:
        return self.v_from_vector_(cp2v_3d(vector))
    
    cdef rt v_from_vector_(self, vec3 vector) except *:
        return self.v_from_xy_(self.xy_from_vector(vector))
    
    # setters
    cpdef void set_xy(self, pos, r) except *:
        cdef int[2] pos_
        pos_[0] = pos[0]
        pos_[1] = pos[1]
        self.set_xy_(pos_, r)
    
    cdef void set_xy_(self, int[2] pos, rt r) nogil except *:
        (<rt *> self._arr)[pos[1] * self.width + pos[0]] = r
    
    @cython.wraparound(False)
    @cython.initializedcheck(False)
    cdef rt sample(self, vec2 pos) nogil except *:
        """
        Samples array at passed position.
    
        Passed x and y positions may be values other than an integer,
        in which case the returned value will be a weighted average of
        the surrounding positions in the array.
        :param arr
        :param pos vec2 indicating x, y position at which to sample array.
        :param w int width of passed array
        :return int
        """
        cdef int p0, p1, p2, p3  # relative array positions
        cdef rt left0, left1, right0, right1, vf
        cdef float a_mod, b_mod
        cdef rt *arr = <rt *> self._arr
    
        pos = mu.vec2Add(pos, self._ref_pos)
    
        a = pos.x
        b = pos.y
        a_mod = a % 1
        b_mod = b % 1
    
        p2 = (<int> pos.y) * self.width + (<int> pos.x)
    
        if a_mod and b_mod:
            # if all 4 pixels are to be used
            p3 = p2 + 1
            p1 = p2 + self.width
            p0 = p1 + 1
    
            left0 = arr[p2]
            left1 = arr[p1]
            right0 = arr[p3]
            right1 = arr[p0]
    
            left0 = mix_region_(left1, b_mod, left0, (1 - b_mod))
            right0 = mix_region_(right1, b_mod, right0, (1 - b_mod))
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif a_mod:  # if a_mod > 0 and b_mod == 0:
            # if only one row
            p3 = p2 + 1
            left0 = arr[p2]
            right0 = arr[p3]
            vf = mix_region_(right0, a_mod, left0, (1 - a_mod))
        elif b_mod:  # if b_mod > 0 and a_mod == 0:
            # if only one column
            p1 = p2 + self.width  # get pixel above base (p2) pixel
            left0 = arr[p2]
            left1 = arr[p1]
            vf = mix_region_(left1, b_mod, left0, (1 - b_mod))
        else:  # both a_mod and b_mod are 0.:
            # if both passed values are whole numbers, just get the
            # corresponding value
            vf = arr[p2]
    
        return vf
    
    

    
    
#######################################################################
# FUNCTIONS
#######################################################################


cpdef vector_from_lat_lon(pos):
    """
    Converts a lat lon position into a Vector
    :param pos: tuple(lat, lon)
    :return: Vector
    """
    cdef vec3 vector_ = vector_from_lat_lon_(cp2ll(pos))
    return Vector((vector_.x, vector_.y, vector_.z))

IF ASSERTS:
    cdef vec3 vector_from_lat_lon_(latlon lat_lon) nogil except *:
        cdef vec3 vector
        cdef double lat = lat_lon.lat, lon = lat_lon.lon

        with gil:
            assert MIN_LAT <= lat <= MAX_LAT + 1e-6, f'bad lat: {lat_lon}'
            assert MIN_LON <= lon <= MAX_LON + 1e-6, f'bad lon: {lat_lon}'

        vector.x = cos(lat) * cos(lon)
        vector.y = cos(lat) * sin(lon)
        vector.z = sin(lat)
        return vector
ELSE:
    cdef vec3 vector_from_lat_lon_(latlon lat_lon) nogil:
        cdef vec3 vector
        cdef double lat = lat_lon.lat, lon = lat_lon.lon

        vector.x = cos(lat) * cos(lon)
        vector.y = cos(lat) * sin(lon)
        vector.z = sin(lat)
        return vector

cpdef lat_lon_from_vector(vector):
    vector = Vector(vector)
    lat = atan2(vector.z, sqrt(pow(vector.x, 2) + pow(vector.y, 2)))
    lon = atan2(vector.y, vector.x)
    return lat, lon


IF ASSERTS:
    @cython.wraparound(False)
    cdef latlon lat_lon_from_vector_(vec3 vector) nogil except *:
        with gil:
            assert not isnan(vector.x), vector
            assert not isnan(vector.y), vector
            assert not isnan(vector.z), vector
            assert vector.x != 0 or vector.y != 0 or vector.z != 0, vector

        cdef latlon lat_lon
        x = vector.x
        y = vector.y
        z = vector.z
        lat_lon.lat = atan2(z, sqrt(pow(x, 2) + pow(y, 2)))
        lat_lon.lon = atan2(y, x)

        with gil:
            assert MIN_LAT <= lat_lon.lat <= MAX_LAT, lat_lon
            assert MIN_LON <= lat_lon.lon <= MAX_LON, lat_lon
        return lat_lon
ELSE:
    @cython.wraparound(False)
    cdef latlon lat_lon_from_vector_(vec3 vector) nogil:
        cdef latlon lat_lon
        x = vector.x
        y = vector.y
        z = vector.z
        lat_lon.lat = atan2(z, sqrt(pow(x, 2) + pow(y, 2)))
        lat_lon.lon = atan2(y, x)
        return lat_lon


#######################################################################
# DATA FUNCTIONS
#######################################################################


cpdef rt pure_region(int region_code) except *:
    """
    Creates new region struct using a single region code
    :param region_code: int identifier for region.
    :return rt
    """
    return pure_region_(region_code)


cdef rt pure_region_(int region_code) nogil except *:
    """
    Creates new region struct using a single region code
    :param region_code: int identifier for region.
    :return rt
    """
    cdef rt r

    if not 0 <= region_code < 256:
        with gil:
            raise ValueError(
                f'region code was outside valid range (0-255): {region_code}')

    r.r0 = region_code
    r.w0 = 1.
    r.r1 = r.r2 = r.r3 = 0
    r.w1 = r.w2 = r.w3 = 0.

    return r


cpdef rt mix_region(rt r0, float w0, rt r1, float w1) except *:
    """
    Combines passed region structs using passed weights
    :param r0: rt
    :param w0: float
    :param r1: rt
    :param w1: float
    :return rt
    """
    return mix_region_(r0, w0, r1, w1)


@cython.cdivision(True)
cdef rt mix_region_(rt r0, float w0, rt r1, float w1) nogil except *:
    """
    Combines passed region structs using passed weights
    :param r0: rt
    :param w0: float
    :param r1: rt
    :param w1: float
    :return rt
    """
    # adjust weights if they do not sum to 1.
    if w0 + w1 != 1.:
        sum = w0 + w1
        w0 = w0 / sum
        w1 = w1 / sum

    # check that each of the two regions have no more than 2
    # region codes
    if r0.w2 or r0.w3:
        with gil:
            raise ValueError(f'r0 has > 2 region codes: {r0}')
    if r1.w2 or r1.w3:
        with gil:
            raise ValueError(f'r1 has > 2 region codes: {r1}')

    # get region codes that will be mixed
    rc0 = r0.r0
    rc1 = r0.r1
    rc2 = r1.r0 if r1.r0 != r0.r0 and r1.r0 != r0.r1 else 0
    rc3 = r1.r1 if r1.r1 != r0.r0 and r1.r1 != r0.r1 else 0

    # get region code weights
    if rc0 != 0:
        rc0w = _get_region_wt(r0, rc0) * w0 + _get_region_wt(r1, rc0) * w1
    else:
        rc0w = 0.
    if rc1 != 0:
        rc1w = _get_region_wt(r0, rc1) * w0 + _get_region_wt(r1, rc1) * w1
    else:
        rc1w = 0.
    if rc2 != 0:
        rc2w = _get_region_wt(r0, rc2) * w0 + _get_region_wt(r1, rc2) * w1
    else:
        rc2w = 0.
    if rc3 != 0:
        rc3w = _get_region_wt(r0, rc3) * w0 + _get_region_wt(r1, rc3) * w1
    else:
        rc3w = 0.
    
    return _make_region(rc0, rc0w, rc1, rc1w, rc2, rc2w, rc3, rc3w)


cdef float _get_region_wt(rt r, int region_code) nogil:
    """
    Gets weight of region code in passed region type
    :return float
    """
    if r.r0 == region_code:
        return r.w0
    elif r.r1 == region_code:
        return r.w1
    elif r.r2 == region_code:
        return r.w2
    elif r.r3 == region_code:
        return r.w3
    else:
        return 0.


cdef rt _make_region(
        int r0, float w0,
        int r1, float w1,
        int r2, float w2,
        int r3, float w3) nogil:
    """
    Creates a region struct from passed data
    :return rt
    """
    cdef rt r
    r.r0 = r0
    r.r1 = r1
    r.r2 = r2
    r.r3 = r3
    r.w0 = w0
    r.w1 = w1
    r.w2 = w2
    r.w3 = w3
    return _sort_region(r)


cdef rt _sort_region(rt r) nogil:
    """
    Given a region struct, returns a region struct created from the
    passed data, but with region codes and weights sorted into
    greatest-to-least order, so that r0 is the region code with
    the greatest weight.
    :param r: rt
    :return rt
    """
    cdef bint sort = True  # whether sorting should continue

    while sort:
        sort = False  # reset flag
        if r.w0 < r.w1:
            sort = True
            r.w0, r.w1 = r.w1, r.w0
            r.r0, r.r1 = r.r1, r.r0
        if r.w1 < r.w2:
            sort = True
            r.w1, r.w2 = r.w2, r.w1
            r.r1, r.r2 = r.r2, r.r1
        if r.w2 < r.w3:
            sort = True
            r.w2, r.w3 = r.w3, r.w2
            r.r2, r.r3 = r.r3, r.r2

    return r

cpdef mix_av(v0, float w0, v1, float w1):
    cdef av v0_, v1_
    v0_.x = v0[0]
    v0_.y = v0[1]
    v1_.x = v1[0]
    v1_.y = v1[1]
    cdef av r = mix_av_(v0_, w0, v1_, w1)
    return r.x, r.y

@cython.cdivision(True)
cdef av mix_av_(av v0, float w0, av v1, float w1) nogil except *:
    cdef av vf

    # adjust weights if needed
    if w0 + w1 != 1.:
        sum = w0 + w1
        w0 = w0 / sum
        w1 = w1 / sum

    vf.x = v0.x * w0 + v1.x * w1
    vf.y = v0.y * w0 + v1.y * w1

    return vf
